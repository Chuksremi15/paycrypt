{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/PopUpStore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// Useful for debugging. Remove when deploying to a live network.\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Use openzeppelin to inherit battle-tested implementations (ERC20, ERC721, etc)\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Import the Chainlink Aggregator interface\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * A smart contract that allows changing a state variable of the contract and tracking the changes\n * It also allows the owner to withdraw the Ether in the contract\n * @author BuidlGuidl\n */\ncontract PopUpStore {\n\t// State Variables\n\taddress public immutable owner;\n\n\tAggregatorV3Interface internal dataFeed;\n\n\tstruct TokenArray {\n\t\tstring tokenName;\n\t\taddress tokenAddress;\n\t}\n\n\tmapping(string => uint256) public itemPrice;\n\n\tTokenArray[] public tokensArray;\n\n\t// Events: a way to emit log statements from smart contract that can be listened to by external parties\n\tevent PaymentReceive(\n\t\taddress indexed payersAddress,\n\t\tstring txDetails,\n\t\tstring tokenName,\n\t\tstring indexed itemId,\n\t\tuint256 amount,\n\t\taddress tokenAddress,\n\t\tuint256 timestamp\n\t);\n\n\t// Events: emit when payment token is added\n\tevent tokenAdded(\n\t\tstring indexed tokenName,\n\t\taddress indexed tokenAddress,\n\t\tuint256 timestamp\n\t);\n\n\t// Events: emit when payment token is remove\n\tevent tokenRemove(\n\t\tstring indexed tokenName,\n\t\taddress indexed tokenAddress,\n\t\tuint256 timestamp\n\t);\n\n\t// Events: emit when token is withdrawn\n\tevent tokenWithdrawn(\n\t\tstring indexed tokenName,\n\t\tuint256 amount,\n\t\tuint256 timestamp\n\t);\n\n\t// Constructor: Called once on contract deployment\n\t// Check packages/hardhat/deploy/00_deploy_your_contract.ts\n\tconstructor(\n\t\taddress _owner,\n\t\taddress _aggregator_address,\n\t\tstring memory _token_name,\n\t\taddress _token_address\n\t) {\n\t\towner = _owner;\n\t\tdataFeed = AggregatorV3Interface(_aggregator_address);\n\t\ttokensArray.push(\n\t\t\tTokenArray({ tokenName: _token_name, tokenAddress: _token_address })\n\t\t);\n\t}\n\n\t/**\n\t * Returns the latest answer for eth price.\n\t */\n\tfunction getChainlinkDataFeedLatestAnswer() public view returns (int) {\n\t\t// prettier-ignore\n\t\t(\n            /* uint80 roundID */,\n            int answer,\n            /*uint startedAt*/,\n            /*uint timeStamp*/,\n            /*uint80 answeredInRound*/\n        ) = dataFeed.latestRoundData();\n\t\treturn answer;\n\t}\n\n\t// Modifier: used to define a set of rules that must be met before or after a function is executed\n\t// Check the withdraw() function\n\tmodifier isOwner() {\n\t\t// msg.sender: predefined variable that represents address of the account that called the current function\n\t\trequire(msg.sender == owner, \"Not the Owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * Function that allows anyone to pay for an item\n\t *\n\t * @param _amount (unit256 memory) - amount pegged to USD to be paid by user\n\t * @param _token_index (string memory) - token index of the token the contracts receive payment in\n\t * @param _itemId (string memory) - itemId to be paid for\n\t */\n\n\tfunction payWithToken(\n\t\tuint256 _amount,\n\t\tuint256 _token_index,\n\t\tstring memory _itemId\n\t) public {\n\t\trequire(_token_index < tokensArray.length, \"Token not found\");\n\t\trequire(_amount >= itemPrice[_itemId], \"Insufficient _amount\");\n\n\t\tTokenArray memory token_ = tokensArray[_token_index];\n\n\t\tIERC20 token = IERC20(token_.tokenAddress);\n\n\t\t//transfer token\n\t\trequire(\n\t\t\ttoken.transferFrom(msg.sender, address(this), _amount),\n\t\t\t\"payment reverted\"\n\t\t);\n\n\t\t// emit: keyword used to trigger an event\n\t\temit PaymentReceive(\n\t\t\tmsg.sender,\n\t\t\t\"Payment Received\",\n\t\t\ttoken_.tokenName,\n\t\t\t_itemId,\n\t\t\t_amount,\n\t\t\ttoken_.tokenAddress,\n\t\t\tblock.timestamp\n\t\t);\n\t}\n\n\t/**\n\t * Function that allows anyone to pay for an item with ETH\n\t * @param _itemId (string memory) - itemId to be paid for\n\t */\n\n\tfunction payWithEth(string memory _itemId) public payable {\n\t\trequire(msg.value > 0, \"Value can not be zero\");\n\n\t\tint ethPrice = getChainlinkDataFeedLatestAnswer();\n\t\tuint256 price = itemPrice[_itemId];\n\n\t\tuint256 valueInEth = safeDivision(price, ethPrice);\n\n\t\trequire(msg.value >= valueInEth, \"Insufficient msg.value\");\n\n\t\t// emit: keyword used to trigger an event\n\t\temit PaymentReceive(\n\t\t\tmsg.sender,\n\t\t\t\"Payment Received\",\n\t\t\t\"ETH\",\n\t\t\t_itemId,\n\t\t\tmsg.value,\n\t\t\tmsg.sender,\n\t\t\tblock.timestamp\n\t\t);\n\t}\n\n\tfunction safeDivision(uint256 a, int256 b) public pure returns (uint256) {\n\t\trequire(b > 0, \"Division by zero or negative number\"); // Ensure b is positive\n\t\tuint256 result = a / uint256(b);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Function that allows the owner to withdraw token in the contract\n\t * The function can only be called by the owner of the contract as defined by the isOwner modifier\n\t */\n\tfunction withdrawToken(\n\t\tuint256 _token_index,\n\t\tuint256 _amount\n\t) public isOwner {\n\t\trequire(_token_index < tokensArray.length, \"Token not found\");\n\t\trequire(_amount > 0, \"cannot withdraw 0 token\");\n\n\t\tTokenArray memory token_ = tokensArray[_token_index];\n\n\t\tIERC20 token = IERC20(token_.tokenAddress);\n\n\t\t//withdraw token\n\t\trequire(token.transfer(msg.sender, _amount), \"payment reverted\");\n\n\t\t// emit event for token withdraw\n\t\temit tokenWithdrawn(token_.tokenName, _amount, block.timestamp);\n\t}\n\n\t/**\n\t * Function to check the token balance of this contract\n\t *\n\t * @param _token_index (string memory) - name of token to check balance\n\t */\n\tfunction getTokenBalance(\n\t\tuint256 _token_index\n\t) public view returns (uint256) {\n\t\trequire(_token_index < tokensArray.length, \"Token not found\");\n\n\t\tTokenArray memory token_ = tokensArray[_token_index];\n\n\t\tIERC20 token = IERC20(token_.tokenAddress);\n\n\t\treturn token.balanceOf(address(this));\n\t}\n\n\t/**\n\t * Function to add tokens payment can be recieve in\n\t *\n\t * @param _token_name (string memory) - name of token to check balance\n\t * @param _token_address (address memory) - name of token to check balance\n\t */\n\tfunction addPaymentToken(\n\t\tstring memory _token_name,\n\t\taddress _token_address\n\t) public isOwner {\n\t\trequire(_token_address != address(0), \"Token not found\");\n\n\t\ttokensArray.push(\n\t\t\tTokenArray({ tokenName: _token_name, tokenAddress: _token_address })\n\t\t);\n\n\t\t// emit when token is added\n\t\temit tokenAdded(_token_name, _token_address, block.timestamp);\n\t}\n\n\t/**\n\t * Function to add tokens payment can be recieve in\n\t *\n\t * @param _token_index (address memory) - index of token to delete\n\t */\n\tfunction removePaymentToken(uint256 _token_index) public isOwner {\n\t\trequire(_token_index < tokensArray.length, \"Token does not exist\");\n\n\t\t// Swap the token to delete with the last token\n\t\ttokensArray[_token_index] = tokensArray[tokensArray.length - 1];\n\n\t\tTokenArray memory token_ = tokensArray[tokensArray.length - 1];\n\n\t\ttokensArray.pop();\n\n\t\t// emit when token is added\n\t\temit tokenRemove(\n\t\t\ttoken_.tokenName,\n\t\t\ttoken_.tokenAddress,\n\t\t\tblock.timestamp\n\t\t);\n\t}\n\n\t/**\n\t * Function to set price of item\n\t * @param _item_id id of item\n\t * @param _price price of item\n\t */\n\tfunction setPrice(string memory _item_id, uint256 _price) public isOwner {\n\t\trequire(_price > 0, \"Price can not be zero\");\n\n\t\titemPrice[_item_id] = _price;\n\t}\n\n\t/**\n\t * Function to get all the values of the tokensArray\n\t */\n\n\tfunction getPaymentTokens() public view returns (TokenArray[] memory) {\n\t\treturn tokensArray;\n\t}\n\n\t/**\n\t * Function that allows the owner to withdraw all the Ether in the contract\n\t * The function can only be called by the owner of the contract as defined by the isOwner modifier\n\t */\n\tfunction withdrawEth(uint256 _amount) public isOwner {\n\t\trequire(_amount > 0, \"cannot withdraw 0 ETH\");\n\t\t(bool success, ) = owner.call{ value: _amount }(\"\");\n\t\trequire(success, \"Failed to send Ether\");\n\t}\n\n\t/**\n\t * Function that allows the contract to receive ETH\n\t */\n\treceive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}